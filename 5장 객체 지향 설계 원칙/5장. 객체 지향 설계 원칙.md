## 단일 책임 원칙 - single responsibility principle

1. 정의
   - 클래스에는 하나의 책임만 있어야 한다.
2. 위반시 증상
   - 서로 다른 이유들로 인해 기능 변경이 필요하게 된다.(뒤엉킨 변경 악취)
   - 기능이 복잡해서 재사용하기 어렵다.(거대한 클래스 악취)
3. 원칙 적용 방법
   - 클래스를 변경하는 이유는 하나여야 한다는 기준으로 기능을 나눈다.

## 개방 폐쇄 원칙 - open closed principle

1. 정의
   - 객체는 확장에 열려 있고 수정에는 닫혀 있어야 한다.
2. 위반시 증상
   - 기능 확장을 할 때마다 기존코드를 수정해야 한다.
   - if else 블록이 자주 등장
   - 기능 확장을 위해 코드 수정시에 여러 클래스에서 다발적으로 진행
3. 원칙 적용 방법
   - 변화되는 부분을 추상화해서 변화를 고정시킨다.
   - 기능 추가사항이 발생하면 클래스 상속을 통해 하위 클래스에서 기능을 구현
   - 기존코드를 수정하지 않더라도 객체 상속의 다형성 원리에 의해 기능확장이 이루어진다.

## 리스코프 치환 원칙 - Liskov substitution principle

1. 정의
   - 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램의 기능은 동일해야 한다.
2. 위반시 증상
   - 객체의 타입 확인을 한다.(instanceof 연산자 사용)
   - 자식 클래스명이 연관되거나 의존성이 있는 클래스에서 자주 보인다.
3. 원칙 적용 방법
   - 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있도록 추상화를 좀 더 정교하게 한다.

## 인터페이스 분리 원칙 - Interface segregation principle

1. 정의
   - 인터페이스는 사용하는 클라이언트를 기준으로 분리해야한다.
2. 위반시 증상
   - 인터페이스에 기능 변경이 발생하면 그 기능과 관계없는 클라이언트에도 수정사항이 발생한다.
3. 원칙 적용 방법
   - 기존 인터페이스를 기능별로 각 클라이언트에 특화시켜서 분리한다.

## 의존 역전 원칙 - Dependency Inversion principle

1. 정의
   - 고수준 모듈은 저수준 모듈에 종속되어서는 안된다.
2. 위반시 증상
   - 저수준에서 변경 발생 가능성이 많은 데 변경될 때마다 고수준 모듈에 수정사항이 발생
3. 원칙 적용 방법
   - 고수준 모듈의 변화되는 부분을 추상화한다.
   - 저수준 모듈을 추상화에 의존시킨다.
